vec3 convert_xyz_to_cube_uv(float x, float y, float z);

ivec2 GetLightOffsetInAtlas(int lightIndex, int framesPerRow, int frameSize)
{
    return ivec2(lightIndex*3 % u_SAtlasFramesPerRow, lightIndex*3 / u_SAtlasFramesPerRow * 2 ) *  u_SFrameSize;
}


float SpotShadowCalc(vec4 fragPosLightSpace, vec3 lightPos, int lightIndex)
{
    // perform perspective divide
    //vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    // transform to [0,1] range
    //projCoords = projCoords * 0.5 + 0.5;
    vec3 projCoords = fragPosLightSpace.xyz;
    // get closest depth value from light's perspective (using [0,1] range fragPosLight as coords)
    ivec2 offset = GetLightOffsetInAtlas(lightIndex, u_SAtlasFramesPerRow, u_SFrameSize);
    vec2 uv = offset + projCoords.xy * u_SFrameSize;
    uv /= u_SAtlasSize;
    float closestDepth = texture(u_SAtlas, uv).r;
    // get depth of current fragment from light's perspective
    float currentDepth = projCoords.z;
    // calculate bias (based on depth map resolution and slope)
    vec3 normal = normalize(fs_in.Normal);
    vec3 lightDir = normalize(lightPos - fs_in.FragPos);
    float bias = max(0.05 * (1.0 - dot(normal, lightDir)), 0.005);
    // check whether current frag pos is in shadow
    float shadow = currentDepth - bias > closestDepth  ? 1.0 : 0.0;
    // PCF
    //float shadow = 0.0;
    //vec2 texelSize = 1.0 / vec2(u_SFrameSize, u_SFrameSize);
    //for (int x = -1; x <= 1; ++x)
    //{
    //    for (int y = -1; y <= 1; ++y)
    //    {
    //        float pcfDepth = texture(u_SAtlas, uv + vec2(x, y) * texelSize).r;
    //        shadow += currentDepth - bias > pcfDepth ? 1.0 : 0.0;
    //    }
    //}
    //shadow /= 9.0;

    // keep the shadow at 0.0 when outside the far_plane region of the light's frustum.
    if (projCoords.z > 1.0)
        shadow = 0.0;
    // display closestDepth as debug (to visualize depth cubemap)
    //FragColor = vec4(vec3(closestDepth / u_PointLightFarPlane), 1.0);

    return shadow;
}

float DirShadowCalc(vec4 fragPosLightSpace, vec3 lightPos, int lightIndex)
{
    // perform perspective divide
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    // transform to [0,1] range
    projCoords = projCoords * 0.5 + 0.5;
    // get closest depth value from light's perspective (using [0,1] range fragPosLight as coords)
    ivec2 offset = GetLightOffsetInAtlas(lightIndex, u_SAtlasFramesPerRow, u_SFrameSize);
    vec2 uv = offset + projCoords.xy * u_SFrameSize;
    uv /= u_SAtlasSize;
    float closestDepth = texture(u_SAtlas, uv).r;
    // get depth of current fragment from light's perspective
    float currentDepth = projCoords.z;
    // calculate bias (based on depth map resolution and slope)
    vec3 normal = normalize(fs_in.Normal);
    vec3 lightDir = normalize(lightPos - fs_in.FragPos);
    float bias = max(0.05 * (1.0 - dot(normal, lightDir)), 0.005);
    // check whether current frag pos is in shadow
    float shadow = currentDepth - bias > closestDepth  ? 1.0 : 0.0;
    // PCF
    //float shadow = 0.0;
    //vec2 texelSize = 1.0 / vec2(u_SFrameSize, u_SFrameSize);
    //for (int x = -1; x <= 1; ++x)
    //{
    //    for (int y = -1; y <= 1; ++y)
    //    {
    //        float pcfDepth = texture(u_SAtlas, uv + vec2(x, y) * texelSize).r;
    //        shadow += currentDepth - bias > pcfDepth ? 1.0 : 0.0;
    //    }
    //}
    //shadow /= 9.0;

    // keep the shadow at 0.0 when outside the far_plane region of the light's frustum.
    if (projCoords.z > 1.0)
        shadow = 0.0;

    return shadow;
}


float PointShadowCalc(vec3 fragPos, vec3 lightPos, int lightIndex)
{
    // get vector between fragment position and light position
    vec3 fragToLight = fragPos - lightPos;
    // ise the fragment to light vector to sample from the depth map    
    //float closestDepth = texture(u_PointLDepthCubemap, fragToLight).r;
    vec3 result = convert_xyz_to_cube_uv(fragToLight.x, fragToLight.y, fragToLight.z);
    int face = int(result.z);

    ivec2 offset = GetLightOffsetInAtlas(lightIndex, u_SAtlasFramesPerRow, u_SFrameSize);

    ivec2 offsetInside = ivec2(face % 3, face / 3) * u_SFrameSize;
    vec2 uv = offset + offsetInside;
    uv += result.xy * u_SFrameSize; //
    uv /= u_SAtlasSize;

    float closestDepth = texture(u_SAtlas, uv).r;
    // it is currently in linear range between [0,1], let's re-transform it back to original depth value
    closestDepth *= u_PointLightFarPlane;
    // now get current linear depth as the length between the fragment and light position
    float currentDepth = length(fragToLight);
    // test for shadows
    float bias = 0.05; // we use a much larger bias since depth is now in [near_plane, far_plane] range
    float shadow = currentDepth - bias > closestDepth ? 1.0 : 0.0;
    // display closestDepth as debug (to visualize depth cubemap)
    //FragColor = vec4(vec3(closestDepth / u_PointLightFarPlane), 1.0);

    return shadow;
}

vec3 convert_xyz_to_cube_uv(float x, float y, float z)
{
    int index = 0;

    float absX = abs(x);
    float absY = abs(y);
    float absZ = abs(z);

    int isXPositive = x > 0 ? 1 : 0;
    int isYPositive = y > 0 ? 1 : 0;
    int isZPositive = z > 0 ? 1 : 0;

    float maxAxis, uc, vc;

    // POSITIVE X
    if (bool(isXPositive) && absX >= absY && absX >= absZ) {
        // u (0 to 1) goes from +z to -z
        // v (0 to 1) goes from -y to +y
        maxAxis = absX;
        uc = -z;
        vc = y;
        index = 0;
    }
    // NEGATIVE X
    if (!bool(isXPositive) && absX >= absY && absX >= absZ) {
        // u (0 to 1) goes from -z to +z
        // v (0 to 1) goes from -y to +y
        maxAxis = absX;
        uc = z;
        vc = y;
        index = 1;
    }
    // POSITIVE Y
    if (bool(isYPositive) && absY >= absX && absY >= absZ) {
        // u (0 to 1) goes from -x to +x
        // v (0 to 1) goes from +z to -z
        maxAxis = absY;
        uc = x;
        vc = -z;
        index = 2;
    }
    // NEGATIVE Y
    if (!bool(isYPositive) && absY >= absX && absY >= absZ) {
        // u (0 to 1) goes from -x to +x
        // v (0 to 1) goes from -z to +z
        maxAxis = absY;
        uc = x;
        vc = z;
        index = 3;
    }
    // POSITIVE Z
    if (bool(isZPositive) && absZ >= absX && absZ >= absY) {
        // u (0 to 1) goes from -x to +x
        // v (0 to 1) goes from -y to +y
        maxAxis = absZ;
        uc = x;
        vc = y;
        index = 4;
    }
    // NEGATIVE Z
    if (!bool(isZPositive) && absZ >= absX && absZ >= absY) {
        // u (0 to 1) goes from +x to -x
        // v (0 to 1) goes from -y to +y
        maxAxis = absZ;
        uc = -x;
        vc = y;
        index = 5;
    }

    // Convert range from -1 to 1 to 0 to 1
    float u = 0.5f * (uc / maxAxis + 1.0f);
    float v = 0.5f * (-vc / maxAxis + 1.0f);

    return vec3(u, v, float(index));
}